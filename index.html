// ============================================
// 2DUELS TELEGRAM BOT BACKEND
// Node.js + Telegram Bot API + Firebase
// ============================================
const TelegramBot = require('node-telegram-bot-api');
const admin = require('firebase-admin');
const express = require('express');
const crypto = require('crypto');
// ============================================
// CONFIGURATION
// ============================================
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://duels-1fb6b-default-rtdb.firebaseio.com"
});
const db = admin.database();
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });
console.log('ðŸš€ 2Duels Bot Started!');
console.log('ðŸ“¡ Listening for commands...');
// ============================================
// EXPRESS SERVER FOR WEBHOOKS (Optional)
// ============================================
const app = express();
app.use(express.json());
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`ðŸŒ Server running on port ${PORT}`);
});
// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: Date.now() });
});
// ============================================
// HELPER FUNCTIONS
// ============================================
// Verify Telegram WebApp data
function verifyTelegramWebAppData(telegramInitData, botToken) {
  const initData = new URLSearchParams(telegramInitData);
  const hash = initData.get('hash');
  const dataToCheck = [];
  initData.sort();
  initData.forEach((val, key) => {
    if (key !== 'hash') {
      dataToCheck.push(`${key}=${val}`);
    }
  });
  const secret = crypto.createHmac('sha256', 'WebAppData').update(botToken).digest();
  const signature = crypto.createHmac('sha256', secret).update(dataToCheck.join('\n')).digest('hex');
  return signature === hash;
}
// Get user balance from Firebase
async function getUserBalance(userId) {
  try {
    const snapshot = await db.ref(`users/${userId}/balance`).once('value');
    return snapshot.val() || 1000; // Default balance
  } catch (error) {
    console.error('Error getting balance:', error);
    return 1000;
  }
}

// Update user balance
async function updateUserBalance(userId, amount) {
  try {
    const currentBalance = await getUserBalance(userId);
    const newBalance = currentBalance + amount;
    await db.ref(`users/${userId}/balance`).set(newBalance);
    return newBalance;
  } catch (error) {
    console.error('Error updating balance:', error);
    return null;
  }
}

// Get user inventory
async function getUserInventory(userId) {
  try {
    const snapshot = await db.ref(`users/${userId}/inventory`).once('value');
    const inventory = snapshot.val() || {};
    return Object.values(inventory);
  } catch (error) {
    console.error('Error getting inventory:', error);
    return [];
  }
}

// Get user stats
async function getUserStats(userId) {
  try {
    const snapshot = await db.ref(`users/${userId}/games`).once('value');
    const games = snapshot.val() || {};
    
    let totalGames = 0;
    let totalWins = 0;
    
    Object.keys(games).forEach(gameType => {
      const gameSessions = Object.values(games[gameType]);
      totalGames += gameSessions.length;
      totalWins += gameSessions.filter(session => session.won || session.cashedOut).length;
    });
    
    return {
      totalGames,
      totalWins,
      winRate: totalGames > 0 ? ((totalWins / totalGames) * 100).toFixed(1) : 0
    };
  } catch (error) {
    console.error('Error getting stats:', error);
    return { totalGames: 0, totalWins: 0, winRate: 0 };
  }
}

// ============================================
// TELEGRAM BOT COMMANDS
// ============================================

// /start command
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const firstName = msg.from.first_name;

  console.log(`ðŸ“¥ /start command from ${firstName} (${userId})`);

  // Save user to Firebase
  await db.ref(`users/${userId}`).update({
    firstName: firstName,
    username: msg.from.username || '',
    lastSeen: Date.now()
  });

  const welcomeMessage = `
ðŸŽ® *2DUELS - TACTICAL MONOLITH*

Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ, ${firstName}!

*Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¸Ð³Ñ€Ñ‹:*
ðŸª™ *Coin Flip* - ÐºÐ»Ð°ÑÑÐ¸Ñ‡ÐµÑÐºÐ°Ñ Ð´ÑƒÑÐ»ÑŒ Ð½Ð° ÑƒÐ´Ð°Ñ‡Ñƒ
ðŸ’£ *Mines* - ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ Ð¼Ð¸Ð½Ð½Ð¾Ðµ Ð¿Ð¾Ð»Ðµ  
ðŸ”« *Russian Roulette* - Ð²Ñ‹ÑÐ¾ÐºÐ¸Ðµ ÑÑ‚Ð°Ð²ÐºÐ¸
ðŸš€ *Crash* - Ñ€Ð°ÑÑ‚ÑƒÑ‰Ð¸Ð¹ Ð¼Ð½Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒ

ðŸ’Ž *NFT Inventory* - Ñ…Ñ€Ð°Ð½Ð¸Ñ‚Ðµ Ð½Ð°Ð³Ñ€Ð°Ð´Ñ‹
â­ *Telegram Stars* - Ð²Ð½ÑƒÑ‚Ñ€Ð¸Ð¸Ð³Ñ€Ð¾Ð²Ð°Ñ Ð²Ð°Ð»ÑŽÑ‚Ð°

_ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ð°Ñ‡Ð°Ñ‚ÑŒ Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ!_
  `.trim();

  bot.sendMessage(chatId, welcomeMessage, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ 
          text: 'ðŸŽ® Ð˜Ð“Ð ÐÐ¢Ð¬', 
          web_app: { url: WEBAPP_URL } 
        }],
        [
          { text: 'ðŸ’° Ð‘Ð°Ð»Ð°Ð½Ñ', callback_data: 'balance' },
          { text: 'ðŸ’Ž Ð˜Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ', callback_data: 'inventory' }
        ],
        [
          { text: 'ðŸ“Š Ð¡Ñ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°', callback_data: 'stats' },
          { text: 'â“ ÐŸÐ¾Ð¼Ð¾Ñ‰ÑŒ', callback_data: 'help' }
        ]
      ]
    }
  });
});

// /balance command
bot.onText(/\/balance/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  console.log(`ðŸ“¥ /balance command from ${userId}`);

  const balance = await getUserBalance(userId);

  bot.sendMessage(chatId, `â­ *Ð’Ð°Ñˆ Ð±Ð°Ð»Ð°Ð½Ñ:* ${balance} Ð·Ð²ÐµÐ·Ð´`, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'ðŸŽ® Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ', web_app: { url: WEBAPP_URL } }],
        [{ text: 'ðŸ’³ ÐŸÐ¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ', callback_data: 'topup' }]
      ]
    }
  });
});

// /inventory command
bot.onText(/\/inventory/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  console.log(`ðŸ“¥ /inventory command from ${userId}`);

  const inventory = await getUserInventory(userId);

  if (inventory.length === 0) {
    bot.sendMessage(chatId, `ðŸ’Ž *Ð’Ð°Ñˆ Ð¸Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ Ð¿ÑƒÑÑ‚*\n\n_Ð’Ñ‹Ð¸Ð³Ñ€Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ Ð² Ð¸Ð³Ñ€Ð°Ñ…, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ NFT Ð¸ Ð½Ð°Ð³Ñ€Ð°Ð´Ñ‹!_`, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'ðŸŽ® Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ', web_app: { url: WEBAPP_URL } }]
        ]
      }
    });
  } else {
    const inventoryText = inventory.map((item, index) => {
      const rarityEmoji = {
        common: 'âšª',
        rare: 'ðŸ”µ',
        epic: 'ðŸŸ£',
        legendary: 'ðŸŸ¡'
      };
      return `${index + 1}. ${item.icon} *${item.name}* ${rarityEmoji[item.rarity] || ''}`;
    }).join('\n');

    bot.sendMessage(chatId, `ðŸ’Ž *Ð’Ð°Ñˆ Ð¸Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ* (${inventory.length} Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚Ð¾Ð²):\n\n${inventoryText}`, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'ðŸŽ® Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ', web_app: { url: WEBAPP_URL } }]
        ]
      }
    });
  }
});

// /stats command
bot.onText(/\/stats/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  console.log(`ðŸ“¥ /stats command from ${userId}`);

  const stats = await getUserStats(userId);
  const balance = await getUserBalance(userId);
  const inventory = await getUserInventory(userId);

  const statsMessage = `
ðŸ“Š *Ð’Ð°ÑˆÐ° ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°*

â­ *Ð‘Ð°Ð»Ð°Ð½Ñ:* ${balance} Ð·Ð²ÐµÐ·Ð´
ðŸ’Ž *NFT Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚Ð¾Ð²:* ${inventory.length}

ðŸŽ® *Ð˜Ð³Ñ€Ñ‹:*
â”œ Ð’ÑÐµÐ³Ð¾ Ð¸Ð³Ñ€: ${stats.totalGames}
â”œ ÐŸÐ¾Ð±ÐµÐ´: ${stats.totalWins}
â”” ÐŸÑ€Ð¾Ñ†ÐµÐ½Ñ‚ Ð¿Ð¾Ð±ÐµÐ´: ${stats.winRate}%
  `.trim();

  bot.sendMessage(chatId, statsMessage, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'ðŸŽ® Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ', web_app: { url: WEBAPP_URL } }]
      ]
    }
  });
});

// /help command
bot.onText(/\/help/, (msg) => {
  const chatId = msg.chat.id;

  console.log(`ðŸ“¥ /help command from ${msg.from.id}`);

  const helpMessage = `
â“ *ÐŸÐžÐœÐžÐ©Ð¬*

*Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹:*
/start - Ð“Ð»Ð°Ð²Ð½Ð¾Ðµ Ð¼ÐµÐ½ÑŽ
/balance - ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð±Ð°Ð»Ð°Ð½Ñ
/inventory - ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¸Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ
/stats - ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ
/help - Ð­Ñ‚Ð° ÑÐ¿Ñ€Ð°Ð²ÐºÐ°

*ÐŸÑ€Ð°Ð²Ð¸Ð»Ð° Ð¸Ð³Ñ€:*

ðŸª™ *ÐžÑ€ÐµÐ» Ð¸ Ð ÐµÑˆÐºÐ°*
ÐšÐ»Ð°ÑÑÐ¸Ñ‡ÐµÑÐºÐ°Ñ Ð¸Ð³Ñ€Ð° Ð½Ð° ÑƒÐ´Ð°Ñ‡Ñƒ. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ñ€Ð¾Ð½Ñƒ Ð¼Ð¾Ð½ÐµÑ‚Ñ‹ Ð¸ Ð¿Ð¾Ð´Ð±Ñ€Ð¾ÑÑŒÑ‚Ðµ. Ð¡Ð¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ðµ = Ð¿Ð¾Ð±ÐµÐ´Ð°!

ðŸ’£ *ÐœÐ¸Ð½Ñ‹*
Ð¡ÐµÑ‚ÐºÐ° 5x5 Ñ Ð¼Ð¸Ð½Ð°Ð¼Ð¸. ÐžÑ‚ÐºÑ€Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ ÑÑ‡ÐµÐ¹ÐºÐ¸, Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚Ðµ Ð³ÐµÐ¼Ñ‹. ÐŸÐ¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ðµ Ð½Ð° Ð¼Ð¸Ð½Ñƒ = Ð¿Ñ€Ð¾Ð¸Ð³Ñ€Ñ‹Ñˆ.

ðŸ”« *Ð ÑƒÑÑÐºÐ°Ñ Ð ÑƒÐ»ÐµÑ‚ÐºÐ°*  
Ð‘Ð°Ñ€Ð°Ð±Ð°Ð½ Ñ€ÐµÐ²Ð¾Ð»ÑŒÐ²ÐµÑ€Ð° Ñ Ð¾Ð´Ð½Ð¸Ð¼ Ð·Ð°Ñ€ÑÐ´Ð¾Ð¼. ÐÐ°Ð¶Ð¸Ð¼Ð°Ð¹Ñ‚Ðµ ÐºÑƒÑ€Ð¾Ðº. Ð’Ñ‹Ð¶Ð¸Ð²Ð°Ð½Ð¸Ðµ = Ð¿Ð¾Ð±ÐµÐ´Ð°!

ðŸš€ *ÐšÑ€Ð°Ñˆ*
Ð Ð°ÐºÐµÑ‚Ð° Ð²Ð·Ð»ÐµÑ‚Ð°ÐµÑ‚ Ñ Ñ€Ð°ÑÑ‚ÑƒÑ‰Ð¸Ð¼ Ð¼Ð½Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÐµÐ¼. Ð—Ð°Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð²Ñ‹Ð¸Ð³Ñ€Ñ‹Ñˆ Ð´Ð¾ Ð²Ð·Ñ€Ñ‹Ð²Ð°!

*ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ°:* @YourSupportUsername
  `.trim();

  bot.sendMessage(chatId, helpMessage, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'ðŸŽ® Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ', web_app: { url: WEBAPP_URL } }]
      ]
    }
  });
});

// ============================================
// CALLBACK QUERY HANDLERS
// ============================================

bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  const userId = query.from.id;
  const data = query.data;

  console.log(`ðŸ“¥ Callback query: ${data} from ${userId}`);

  // Answer callback query to remove loading state
  bot.answerCallbackQuery(query.id);

  switch (data) {
    case 'balance':
      const balance = await getUserBalance(userId);
      bot.sendMessage(chatId, `â­ *Ð’Ð°Ñˆ Ð±Ð°Ð»Ð°Ð½Ñ:* ${balance} Ð·Ð²ÐµÐ·Ð´`, {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ðŸŽ® Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ', web_app: { url: WEBAPP_URL } }],
            [{ text: 'ðŸ’³ ÐŸÐ¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ', callback_data: 'topup' }]
          ]
        }
      });
      break;

    case 'inventory':
      const inventory = await getUserInventory(userId);
      if (inventory.length === 0) {
        bot.sendMessage(chatId, `ðŸ’Ž *Ð’Ð°Ñˆ Ð¸Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ Ð¿ÑƒÑÑ‚*\n\n_Ð’Ñ‹Ð¸Ð³Ñ€Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ Ð² Ð¸Ð³Ñ€Ð°Ñ…!_`, {
          parse_mode: 'Markdown'
        });
      } else {
        const inventoryText = inventory.map((item, index) => 
          `${index + 1}. ${item.icon} ${item.name}`
        ).join('\n');
        bot.sendMessage(chatId, `ðŸ’Ž *Ð˜Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ:*\n\n${inventoryText}`, {
          parse_mode: 'Markdown'
        });
      }
      break;

    case 'stats':
      const stats = await getUserStats(userId);
      bot.sendMessage(chatId, 
        `ðŸ“Š *Ð¡Ñ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°:*\n\nÐ˜Ð³Ñ€: ${stats.totalGames}\nÐŸÐ¾Ð±ÐµÐ´: ${stats.totalWins}\nWin rate: ${stats.winRate}%`,
        { parse_mode: 'Markdown' }
      );
      break;

    case 'help':
      bot.sendMessage(chatId, `â“ Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ /help Ð´Ð»Ñ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½Ð¾Ð¹ ÑÐ¿Ñ€Ð°Ð²ÐºÐ¸`);
      break;

    case 'topup':
      // TODO: Implement Telegram Stars payment
      bot.sendMessage(chatId, 
        `ðŸ’³ *ÐŸÐ¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð±Ð°Ð»Ð°Ð½ÑÐ°*\n\n_Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¿Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ñ‡ÐµÑ€ÐµÐ· Telegram Stars Ð±ÑƒÐ´ÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð° ÑÐºÐ¾Ñ€Ð¾!_`,
        { 
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [{ text: 'ðŸŽ® Ð˜Ð³Ñ€Ð°Ñ‚ÑŒ', web_app: { url: WEBAPP_URL } }]
            ]
          }
        }
      );
      break;

    default:
      bot.sendMessage(chatId, `ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°: ${data}`);
  }
});

// ============================================
// TELEGRAM STARS PAYMENT INTEGRATION
// (Future implementation)
// ============================================

/*
// Invoice creation
bot.onText(/\/buy (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const productId = match[1];

  const prices = {
    'stars_100': { amount: 100, price: 1 },
    'stars_500': { amount: 500, price: 4 },
    'stars_1000': { amount: 1000, price: 7 }
  };

  const product = prices[productId];
  
  if (!product) {
    bot.sendMessage(chatId, 'ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½');
    return;
  }

  bot.sendInvoice(
    chatId,
    `${product.amount} Ð·Ð²ÐµÐ·Ð´`,
    `ÐŸÐ¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð±Ð°Ð»Ð°Ð½ÑÐ° Ð½Ð° ${product.amount} Ð·Ð²ÐµÐ·Ð´`,
    productId,
    'XTR', // Telegram Stars currency
    [{ label: `${product.amount} Ð·Ð²ÐµÐ·Ð´`, amount: product.price }],
    {
      photo_url: 'https://example.com/star-icon.png',
      photo_width: 512,
      photo_height: 512
    }
  );
});

// Handle successful payment
bot.on('pre_checkout_query', (query) => {
  bot.answerPreCheckoutQuery(query.id, true);
});

bot.on('successful_payment', async (msg) => {
  const userId = msg.from.id;
  const productId = msg.successful_payment.invoice_payload;
  
  const prices = {
    'stars_100': 100,
    'stars_500': 500,
    'stars_1000': 1000
  };
  
  const amount = prices[productId];
  
  if (amount) {
    await updateUserBalance(userId, amount);
    bot.sendMessage(msg.chat.id, 
      `âœ… ÐŸÐ»Ð°Ñ‚ÐµÐ¶ ÑƒÑÐ¿ÐµÑˆÐµÐ½!\n\nâ­ ÐÐ°Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¾: ${amount} Ð·Ð²ÐµÐ·Ð´`
    );
  }
});
*/

// ============================================
// WEB APP DATA ENDPOINT
// ============================================

app.post('/webapp/auth', (req, res) => {
  const { initData } = req.body;

  if (!initData) {
    return res.status(400).json({ error: 'Missing initData' });
  }

  // Verify Telegram data signature
  const isValid = verifyTelegramWebAppData(initData, TELEGRAM_BOT_TOKEN);

  if (!isValid) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  // Parse user data
  const params = new URLSearchParams(initData);
  const userJson = params.get('user');
  const user = JSON.parse(userJson);

  // Create custom Firebase token
  admin.auth()
    .createCustomToken(user.id.toString())
    .then(customToken => {
      res.json({ 
        success: true, 
        token: customToken,
        user: user
      });
    })
    .catch(error => {
      console.error('Error creating custom token:', error);
      res.status(500).json({ error: 'Token creation failed' });
    });
});

// ============================================
// GAME EVENTS LOGGING
// ============================================

app.post('/game/event', async (req, res) => {
  const { userId, gameType, eventType, data } = req.body;

  console.log(`ðŸŽ® Game event: ${gameType} - ${eventType} by user ${userId}`);

  try {
    await db.ref(`events/${userId}/${gameType}`).push({
      eventType,
      data,
      timestamp: Date.now()
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error logging event:', error);
    res.status(500).json({ error: 'Failed to log event' });
  }
});

// ============================================
// LEADERBOARD
// ============================================

app.get('/leaderboard', async (req, res) => {
  try {
    const usersSnapshot = await db.ref('users').once('value');
    const users = usersSnapshot.val() || {};

    const leaderboard = Object.entries(users)
      .map(([userId, userData]) => ({
        userId,
        firstName: userData.firstName || 'Unknown',
        balance: userData.balance || 0
      }))
      .sort((a, b) => b.balance - a.balance)
      .slice(0, 10);

    res.json({ leaderboard });
  } catch (error) {
    console.error('Error getting leaderboard:', error);
    res.status(500).json({ error: 'Failed to get leaderboard' });
  }
});

// ============================================
// ERROR HANDLING
// ============================================

bot.on('polling_error', (error) => {
  console.error('âŒ Polling error:', error);
});

process.on('unhandledRejection', (error) => {
  console.error('âŒ Unhandled rejection:', error);
});

process.on('uncaughtException', (error) => {
  console.error('âŒ Uncaught exception:', error);
});

// ============================================
// GRACEFUL SHUTDOWN
// ============================================

process.on('SIGINT', async () => {
  console.log('\nðŸ‘‹ Shutting down bot...');
  await bot.stopPolling();
  process.exit(0);
});

console.log('âœ… Bot initialization complete!');
console.log(`ðŸŒ Web App URL: ${WEBAPP_URL}`);
console.log('ðŸ’¬ Ready to receive commands!');
  "name": "2duels-bot",
  "version": "1.0.0",
  "description": "2Duels Tactical Monolith - Telegram Mini App Bot Backend",
  "main": "bot.js",
  "scripts": {
    "start": "node bot.js",
    "dev": "nodemon bot.js",
    "test": "echo \"No tests yet\" && exit 0"
  },
  "keywords": [
    "telegram",
    "bot",
    "miniapp",
    "games",
    "firebase",
    "2duels"
  ],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "node-telegram-bot-api": "^0.64.0",
    "firebase-admin": "^12.0.0",
    "express": "^4.18.2",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  }
}
 
